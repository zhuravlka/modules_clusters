count_Corr_27.08.R

#!Функции:

load.all.data<-function(input.file)
	принимает список с именами модулей, подгружает данные в виде 
	RangedData  в списке, соответственно подгружает модули и связанные с ними по названиям
	трэки для brain active and all
 return(list(modules.tracks,cluster.active.tracks,cluster.all.tracks,cluster.brain.tracks))

countCorr<-function(tracks.query, tracks.reference,result_array)
	функция для запуска GenometriCorrelation и подсчета корреляционных статистик
	принимает параметры - наборы данных query и reference, 
	а также название матрицы, в которую запишутся результаты подсчета, возвращает эту матрицу	 
 return(list(result_array))

create.result.array<-function(tracks_1, tracks_2)
	создает массив, в котором размерность по строкам и по столбцам соответствует 
	исходным двум наборам данных (tracks_1 и tracks_2), а также дает им соответствующие названия по измерениям
	возвращает этот массив
  return(result_array)
	
change_modules_starts<-function(modules.tracks, upstream)
	принимает данные о координатах стартов генов в модулях и число - расстояние в upstream,
	на которое необходимо увеличить интревалы для интревалов по модулям
	возвращает исходный список с измененными данными по модулям
 return(modules.tracks)
	
change_modules_ends<-function(modules.tracks, downstream)
	то же, что и change_modules_starts, 
	но делает это для downstream'ов
 return(modules.tracks)

load.modules<-function(input.modules.list)
	принимает на чтение файл - список модулей и грузит только файлы с данными по модулям
	возвращает список с RangedData по модулям(не грузит трэки, нужно, когда мы хотим сгенерировать трэки сами)
 return(modules.tracks)

make.clusters.coords<-function(modules.tracks)
	принимает на вход список с координатами генов в модулях, по каждому из модулей
	генерируются списки для данных по трэкам для brain, all, active
	Берутся старты модулей, генерируется случайное число - координата левого конца интервала 
	для разметки соответствующего кластера, в пределах от X-Z до X, где X- 'это старт модуля,
	а Z - это соответственно 10.000 для brain кластеров, 20.000 для active кластеров и 30.000 для all кластеров.
	дальше генерируется случайное число - координата правого конца - в интервале от левой координаты до левая_координата+5000. 
	возвращает сгенрированные списки с данными по кластерам, соответственно brain, active, all
 return(list(clusters.brain, clusters.active, clusters.all)) 

#!Запуск скрипта:
	в скрипт передаются на вход 9(7) параметров,
	первый - название файла, в котором записаны имена модулей
		data/папки с данными(начинается на out, параметром 4 показываем в какую из трех папок с данными смотрим)
			/modules_list.txt 
	второй - это название сохраняемого файла, в результате работы скрипта, 
	третий - тип кластеров
	4-й - тип подсчета кластеров
	пятый указатель на наличие шестого параметра
	шестой  - число отступить в upstream для инетрвалов модулей
	седьмой - указатель на наличий 8-го параметра, 
	восьмой - число , сколько брать в downstream
	девятый - -g указатель на то, что надо генерировать интервалы для кластеров из координат модулей

Example:
R CMD BATCH --no-save --no-restore "--args  modules_list.txt test.RData brain best1 -u 10000 -d 1000 -g" count_Corr_27.08.R

важно: должна быть струтура скрипт лежит в папке в которо есть папка data, папка result, для записи результатов


#!Обработка функциями:
*везде учитывается наличие параметров
1) Есть файл modules_list.txt  , в нем перечисленны все названия модулей
если нет параметра -g, то 
	этот список передается в функцию load.all.data, функция возвращает список с данными по модулям, название 
	для каждого элемента списка - соответствует имени модулю, элементы списка - RangedData, а также подгужает данные по трэкам 
	для сайтов связывания TF - brain, active , all 
если есть параметр -g, то 
	данные по коодинатам сайтов TFB по модулям, генерировался, то вместо 
	функции load_all, нужно вызвать функцию load_modules, а также сгенерировать эти данные по кластерам
	запуском функции make.clusters.coords, в остальном - также

2)  если есть параметры -u -d  использовать функции change_modules_starts и change_modules_ends, 
на данных по модулям

3) Создаем для каждого из трэков функцией create.result.array - массив, в который будем писать данные подсчета корреляционных статистик

4) Считаем корреляционные статистики функцией countCorr(обычно для одного из набора кластеров)

5) Сохраняем наш массив(с корреляционными сатистиками в файл, название которого - первый аргумент в вызове скрипта)



#####небольшие изменения 


Example:
R CMD BATCH --no-save --no-restore '--args  modules_list.txt test.RData brain' count_Corr_27.08.R


