count_Corr_27.08.R

#!Функции:

load.all.data<-function(input.file)
	принимает список с именами модулей, подгружает данные в виде 
	RangedData  в списке, соответственно подгружает модули и связанные с ними по названиям
	трэки для brain active and all
 return(list(modules.tracks,cluster.active.tracks,cluster.all.tracks,cluster.brain.tracks))

countCorr<-function(tracks.query, tracks.reference,result_array)
	функция для запуска GenometriCorrelation и подсчета корреляционных статистик
	принимает параметры - наборы данных query и reference, 
	а также название матрицы, в которую запишутся результаты подсчета, возвращает эту матрицу	 
 return(list(result_array))

create.result.array<-function(tracks_1, tracks_2)
	создает массив, в котором размерность по строкам и по столбцам соответствует 
	исходным двум наборам данных (tracks_1 и tracks_2), а также дает им соответствующие названия по измерениям
	возвращает этот массив
  return(result_array)
	
change_modules_starts<-function(modules.tracks, upstream)
	принимает данные о координатах стартов генов в модулях и число - расстояние в upstream,
	на которое необходимо увеличить интревалы для интревалов по модулям
	возвращает исходный список с измененными данными по модулям
 return(modules.tracks)
	
change_modules_ends<-function(modules.tracks, downstream)
	то же, что и change_modules_starts, 
	но делает это для downstream'ов
 return(modules.tracks)

load.modules<-function(input.modules.list)
	принимает на чтение файл - список модулей и грузит только файлы с данными по модулям
	возвращает список с RangedData по модулям(не грузит трэки, нужно, когда мы хотим сгенерировать трэки сами)
 return(modules.tracks)

make.clusters.coords<-function(modules.tracks)
	принимает на вход список с координатами генов в модулях, по каждому из модулей
	генерируются списки для данных по трэкам для brain, all, active
	Берутся старты модулей, генерируется случайное число - координата левого конца интервала 
	для разметки соответствующего кластера, в пределах от X-Z до X, где X- 'это старт модуля,
	а Z - это соответственно 10.000 для brain кластеров, 20.000 для active кластеров и 30.000 для all кластеров.
	дальше генерируется случайное число - координата правого конца - в интервале от левой координаты до левая_координата+5000. 
	возвращает сгенрированные списки с данными по кластерам, соответственно brain, active, all
 return(list(clusters.brain, clusters.active, clusters.all)) 

#!Запуск скрипта:
	в скрипт передаются на вход три параметра, 
	первый - это название сохраняемого файла, в результате работы скрипта, 
	в этом файле - матрицца с результатом подсчета корреляционных статистик
	второй - это название рассматриваемых трэков по кластерам
	третий - это название матрицы, в которую будут записаны результаты подсчета корреляционных статистик
Example:
R CMD BATCH --no-save --no-restore '--args test.RData cluster.brain.tracks correlation_result.module_cluster_brain' count_Corr_27.08.R


#!Обработка функциями:

1) Есть файл modules_list.txt в текущей директории, в нем перечисленны все названия модулей
этот список передается в функцию load.all.data, функция возвращает список с данными по модулям, название 
для каждого элемента списка - соответствует имени модулю, элементы списка - RangedData, а также подгужает данные по трэкам 
для сайтов связывания TF - brain, active , all 

2)  Если надо, то можно использовать функции change_modules_starts и change_modules_ends, 
на данных по модулям

3) Создаем для каждого из трэков функцией create.result.array - массив, в который будем писать данные подсчета корреляционных статистик

4) Считаем корреляционные статистики функцией countCorr(обычно для одного из набора кластеров)

5) Сохраняем наш массив(с корреляционными сатистиками в файл, название которого - первый аргумент в вызове скрипта)

*Если мы хотим, чтобы данные по коодинатам сайтов TFB по модулям, генерировался, то вместо 
функции load_all, нужно вызвать функцию load_modules, а также сгенерировать эти данные по кластерам
запуском функции make.clusters.coords, в остальном - также

 



